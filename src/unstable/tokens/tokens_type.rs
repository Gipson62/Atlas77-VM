use std::fmt;

#[derive(Clone, Debug, PartialEq)]
/// List of possible `TokenType`.
pub(crate) enum TokenType {
    // Single characters tokens.
    TTLParen,
    TTRParen,
    TTLSquare,
    TTRSquare,
    TTLBrace,
    TTRBrace,
    TTComma,
    TTDot,
    TTMinus,
    TTPlus,
    TTSemicolon,
    TTSlash,
    TTStar,
    TTPower,
    TTModulo,
    // One or two character tokens.
    TTNot,
    TTNotEqual,
    TTEqual,
    TTDoubleEqual,
    TTGreaterThan,
    TTGreaterThanEqual,
    TTLessThan,
    TTLessThanEqual,
    TTArrow,
    // Literals.
    TTIdentifier,
    TTString,
    TTInt,
    TTFloat,
    // Keywords.
    TTAnd,
    TTClass,
    TTElse,
    TTFalse,
    TTFunc,
    TTFor,
    TTIf,
    TTNone,
    TTOr,
    TTPrint,
    TTReturn,
    TTSuper,
    TTThis,
    TTTrue,
    TTVar,
    TTWhile,
    TTLoop,
    TTStruct,
    TTBreak,
    TTContinue,
    // End of file.
    TTEndOfFile,
}
impl fmt::Display for TokenType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TokenType::TTLParen => write!(f, "LParen"),
            TokenType::TTRParen => write!(f, "RParen"),
            TokenType::TTLSquare => write!(f, "LSquare"),
            TokenType::TTRSquare => write!(f, "RSquare"),
            TokenType::TTLBrace => write!(f, "LBrace"),
            TokenType::TTRBrace => write!(f, "RBrace"),
            TokenType::TTComma => write!(f, "Comma"),
            TokenType::TTDot => write!(f, "Dot"),
            TokenType::TTMinus => write!(f, "Minus"),
            TokenType::TTArrow => write!(f, "Arrow"),
            TokenType::TTPlus => write!(f, "Plus"),
            TokenType::TTSemicolon => write!(f, "Semicolon"),
            TokenType::TTSlash => write!(f, "Slash"),
            TokenType::TTStar => write!(f, "Star"),
            TokenType::TTPower => write!(f, "Power"),
            TokenType::TTModulo => write!(f, "Modulo"),
            TokenType::TTNot => write!(f, "Not"),
            TokenType::TTNotEqual => write!(f, "NotEqual"),
            TokenType::TTEqual => write!(f, "Equal"),
            TokenType::TTDoubleEqual => write!(f, "DoubleEqual"),
            TokenType::TTGreaterThan => write!(f, "GreaterThan"),
            TokenType::TTGreaterThanEqual => write!(f, "GreaterThanEqual"),
            TokenType::TTLessThan => write!(f, "LessThan"),
            TokenType::TTLessThanEqual => write!(f, "LessThanEqual"),
            TokenType::TTIdentifier => write!(f, "Identifier"),
            TokenType::TTString => write!(f, "String"),
            TokenType::TTInt => write!(f, "Int"),
            TokenType::TTFloat => write!(f, "Float"),
            TokenType::TTAnd => write!(f, "And"),
            TokenType::TTClass => write!(f, "Class"),
            TokenType::TTElse => write!(f, "Else"),
            TokenType::TTFalse => write!(f, "False"),
            TokenType::TTFunc => write!(f, "Func"),
            TokenType::TTFor => write!(f, "For"),
            TokenType::TTIf => write!(f, "If"),
            TokenType::TTNone => write!(f, "None"),
            TokenType::TTOr => write!(f, "Or"),
            TokenType::TTPrint => write!(f, "Print"),
            TokenType::TTReturn => write!(f, "Return"),
            TokenType::TTSuper => write!(f, "Super"),
            TokenType::TTThis => write!(f, "This"),
            TokenType::TTTrue => write!(f, "True"),
            TokenType::TTVar => write!(f, "Var"),
            TokenType::TTWhile => write!(f, "While"),
            TokenType::TTEndOfFile => write!(f, "EndOfFile"),
            TokenType::TTLoop => write!(f, "Loop"),
            TokenType::TTStruct => write!(f, "Struct"),
            TokenType::TTBreak => write!(f, "Break"),
            TokenType::TTContinue => write!(f, "Continue"),
        }
    }
}